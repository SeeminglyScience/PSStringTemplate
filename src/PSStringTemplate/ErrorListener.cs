using System;
using System.Diagnostics;
using System.Management.Automation;
using System.Management.Automation.Language;
using System.Globalization;
using Antlr4.StringTemplate;
using Antlr4.StringTemplate.Misc;
using Antlr.Runtime;

using Token = Antlr4.StringTemplate.Compiler.TemplateLexer.TemplateToken;
using Strings = PSStringTemplate.Properties.Resources;

namespace PSStringTemplate
{
    /// <summary>
    /// Intercepts errors generated by <see cref="Template"/> objects and creates
    /// terminating error records that a PowerShell user would expect.
    /// </summary>
    internal class ErrorListener : ITemplateErrorListener {
        /// <summary>
        /// Cmdlet context to use so invocation messages are correct.
        /// </summary>
        private Cmdlet ErrorContext { get; }

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="terminatingErrorContext">The cmdlet invocation context to throw from.</param>
        internal ErrorListener (Cmdlet terminatingErrorContext)
        {
            Debug.Assert(terminatingErrorContext != null, "terminatingErrorContext != null");
            ErrorContext = terminatingErrorContext;
        }
        /// <summary>
        /// Handles errors at template compile time, typically related to parsing issues.
        /// </summary>
        /// <param name="msg">The message from Antlr.</param>
        public void CompiletimeError(TemplateMessage msg)
        {
            if (msg == null)
            {
                ThrowUnhandledError("CompiletimeError", null);
                return;
            }

            var message = msg as TemplateCompiletimeMessage;

            var token = message?.Token as Token;

            ScriptExtent extent;
            if (token == null)
            {
                var emptyPosition = new ScriptPosition(string.Empty, 0, 0, string.Empty);
                extent = new ScriptExtent(emptyPosition, emptyPosition);
            }
            else
            {
                var chars = token.InputStream as ANTLRStringStream;
                var line = chars?.Substring(0, chars.Count);

                var start = new ScriptPosition(string.Empty,
                    token.Line,
                    token.CharPositionInLine + 1,
                    line);

                extent = new ScriptExtent(start, start);
            }

            var errors = new ParseError[1];
            errors[0] = new ParseError(extent, "CompiletimeError", message?.Arg as string);

            ErrorContext.ThrowTerminatingError(new ErrorRecord(
                new ParseException(errors),
                "CompiletimeError",
                ErrorCategory.ParserError,
                msg.Self));
        }

        public void InternalError(TemplateMessage msg)
        {
            ThrowUnhandledError("InternalError", msg);
        }

        public void IOError(TemplateMessage msg)
        {
            ThrowUnhandledError("IOError", msg);
        }

        /// <summary>
        /// Handles errors thrown while a template is rendering.
        /// </summary>
        /// <param name="msg">The message from Antlr.</param>
        public void RuntimeError(TemplateMessage msg)
        {
            if (msg == null)
            {
                ThrowUnhandledError("RuntimeError", null);
                return;
            }

            // Ignore missed parameters to be more consistent with how PowerShell handles
            // null values. Might be worth adding a "Strict" switch parameter.
            if (msg.Error.Message.Equals(@"attribute {0} isn't defined"))
            {
                ErrorContext.WriteDebug(string.Format(CultureInfo.CurrentCulture,
                    Strings.DebugArgumentNotFound,
                    msg.Arg as string, msg.Self.Name));
                return;
            }

            if (msg.Error.Message.Equals(@"no such property or can't access: {0}"))
            {
                ErrorContext.WriteDebug(string.Format(CultureInfo.CurrentCulture,
                    Strings.DebugPropertyNotFound,
                    msg.Arg as string, msg.Self.Name));
                return;
            }

            var antlrMessage = msg.ToString();
            var fullMessage = string.Format(CultureInfo.CurrentCulture,
                                            Strings.RuntimeExceptionWrapper, msg.Self.Name, antlrMessage);
            ErrorContext.ThrowTerminatingError(new ErrorRecord(
                new RuntimeException(fullMessage),
                "RuntimeError",
                ErrorCategory.InvalidOperation,
                msg));
        }
        /// <summary>
        /// Throws a generate error record for any unanticipated exception.
        /// </summary>
        /// <param name="id">The ErrorId we want to show in the error record to help narrow down context.</param>
        /// <param name="msg">The message passed to the caller from Antlr.</param>
        private void ThrowUnhandledError(string id, TemplateMessage msg)
        {
            var exceptionMessage = string.Format(
                CultureInfo.CurrentCulture,
                Strings.UnhandledErrorMessage,
                msg.ToString());
            ErrorContext.ThrowTerminatingError(new ErrorRecord(
                new NotImplementedException(exceptionMessage),
                id,
                ErrorCategory.NotImplemented,
                msg));
        }
    }
}
